//*********************************************************
//
//    Copyright (c) Microsoft. All rights reserved.
//
//    THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
//    ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
//    IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
//    PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.
//
//*********************************************************

using System;
using System.Runtime.Serialization;
using UProveCrypto.Math;

namespace UProveCrypto.PolyProof
{
    /// <summary>
    /// This interface represents statements about which proofs-of-knowledge may be created.
    /// The statement consists of Base[0],...,Base[n], Value.  The prover must demonstrate
    /// that he knows Exponent[0],...,Exponent[n] such that F(Base[0],...,Base[n], Exponent[0], ..., Exponent[n])=Value
    /// for some formula F. The class implementing the interface determines F.
    /// </summary>
    public interface IStatement : IGroupParameterizedSerialization
    {
        /// <summary>
        /// Is this statement also a witness?
        /// </summary>
        bool IsWitness { get; }

        /// <summary>
        /// Value such that  F(Base[0],...,Base[n], Exponent[0], ..., Exponent[n])=Value
        /// </summary>
        GroupElement Value { get; }

        /// <summary>
        /// Should bases be serialized during serialization?
        /// </summary>
        bool AreBasesSerializable { get; set; }

        /// <summary>
        /// Used to compare two IStatements.
        /// </summary>
        /// <param name="statement">Statement</param>
        /// <returns></returns>
        bool Equals(Object statement);

        /// <summary>
        /// Number of Bases.
        /// </summary>
        int RepresentationLength { get; }

        /// <summary>
        /// Verifies the response to a sigma protocol.
        /// </summary>
        /// <param name="commitment">Commitment to this statement generated by prover.</param>
        /// <param name="challenge">Random challenge generated by verifier (or via Fiat-Shamir heuristic).</param>
        /// <param name="response">Prover response to challenge.</param>
        /// <returns></returns>
        bool Verify(GroupElement commitment, FieldZqElement challenge, FieldZqElement[] response);

        /// <summary>
        /// Returns the indicated base.
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        GroupElement BaseAtIndex(int index);

        /// <summary>
        /// Compares the bases in this IStatement to those in statement.
        /// </summary>
        /// <param name="statement"></param>
        /// <returns></returns>
        bool AreBasesEqual(IStatement statement);

        /// <summary>
        /// Must be called after deserialization completes. 
        /// </summary>
        /// <param name="group">May be null. Group to use if group was not serialized.</param>
        /// <param name="bases">May be null.  Bases to use if bases were not serialized.</param>
        void FinishDeserializing(Group group, GroupElement[] bases);
    }

    /// <summary>
    /// Witness to an IStatement. Contains the statement, as well as
    /// Exponents[0],...,Exponents[n] that satisfy the statement.
    /// </summary>
    public interface IWitness : IStatement
    {
        /// <summary>
        /// Gets statement version of this Witness. Must be cleaned up to not contain Exponents.
        /// </summary>
        /// <returns></returns>
        IStatement GetStatement();

        /// <summary>
        /// Computes a commitment to this object - first element in EqualityProof Sigma protocol.
        /// </summary>
        /// <param name="randomData">Randomness for creating commitment.  Length of array should be equal to the RepresentationLength</param>
        /// <returns></returns>
        GroupElement ComputeCommitment(FieldZqElement[] randomData);

        /// <summary>
        /// Computes an array of responses given the challenge and randomData.
        /// </summary>
        /// <param name="challenge">Challenge (second element in Sigma protocol)</param>
        /// <param name="randomData">Same random data as used to ComputeCommitment.</param>
        /// <param name="exponentIndex">Index of exponent</param>
        /// <returns>FieldZq element.</returns>
        FieldZqElement ComputeResponse(FieldZqElement challenge, FieldZqElement randomData, int exponentIndex);

        /// <summary>
        /// Returns the requested exponent.
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        FieldZqElement ExponentAtIndex(int index);
    }


    /// <summary>
    /// This is a statement for EqualityProof.
    /// Objects that implement this interface represent a function F(GroupElement [] bases, FieldZqElement [] exponents) = value. This object
    /// stores the bases and value. The exponents are unknown.
    /// </summary>
    [DataContract]
    public abstract class EqualityProofWitnessStatement : GroupParameterizedSerializer
    {
       /// <summary>
       /// True means this object is a witness, false means it is a statement.
       /// </summary>
        public abstract bool IsWitness { get; }

        /// <summary>
        /// Value of this object.
        /// </summary>
        public GroupElement Value { get; set; }

        /// <summary>
        /// Array of bases.
        /// </summary>
        internal GroupElement[] Bases;

        /// <summary>
        /// Array of exponents.
        /// </summary>
        internal FieldZqElement[] Exponents;

        /// <summary>
        /// Should bases be serialized.
        /// </summary>
        [DataMember]
        public bool AreBasesSerializable { get; set; }


        /// <summary>
        /// Returns the number of bases in this object.
        /// </summary>
        public int RepresentationLength
        {
            get
            {
                if (this.Bases == null)
                {
                    return 0;
                }
                else
                {
                    return this.Bases.Length;
                }
            }
        }


        /// <summary>
        /// Returns a statement version of this witness.
        /// </summary>
        /// <returns></returns>
        public abstract IStatement GetStatement();

        /// <summary>
        /// Verifies that the given (commitment, challenge, response) values are a
        /// valid proof for this object.  See IOpenEquation for how commitment and response are generated.
        /// </summary>
        /// <param name="challenge">The challenge for this proof (second step in Sigma protocol).</param>
        /// <param name="responseValues">The response (third step in Sigma protocol).</param>
        /// <param name="commitment">The commitment (first step in Sigma protocol).</param>
        /// <returns></returns>
        public abstract bool Verify(GroupElement commitment, FieldZqElement challenge, FieldZqElement[] response);


        /// <summary>
        /// Computes a commitment to this object - first element in EqualityProof Sigma protocol.
        /// </summary>
        /// <param name="randomData">Randomness for creating commitment.  Length of array should be equal to the RepresentationLength</param>
        /// <returns></returns>
        public abstract GroupElement ComputeCommitment(FieldZqElement[] randomData);

        /// <summary>
        /// Computes an array of responses given the challenge and randomData.
        /// </summary>
        /// <param name="challenge">Challenge (second element in Sigma protocol)</param>
        /// <param name="randomData">Same random data as used to ComputeCommitment.</param>
        /// <param name="exponentIndex">Index of exponent</param>
        /// <returns>FieldZq element.</returns>
        public abstract FieldZqElement ComputeResponse(FieldZqElement challenge, FieldZqElement randomData, int exponentIndex);



        /// <summary>
        /// Compares the bases of two statements.
        /// </summary>
        /// <param name="statement"></param>
        /// <returns></returns>
        public bool AreBasesEqual(IStatement statement)
        {
            if (statement == null)
            {
                return false;
            }

            if (this.RepresentationLength != statement.RepresentationLength)
            {
                return false;
            }

            for (int i = 0; i < this.RepresentationLength; ++i)
            {
                if (this.BaseAtIndex(i) != statement.BaseAtIndex(i))
                {
                    return false;
                }
            }

            return true;
        }

        /// <summary>
        /// Returns the base at index.
        /// </summary>
        /// <param name="index">0-based index.</param>
        /// <returns></returns>
        public GroupElement BaseAtIndex(int index)
        {
            if ((index < 0) || (index >= this.RepresentationLength))
            {
                throw new IndexOutOfRangeException("index out of range.");
            }

            return this.Bases[index];
        }

        /// <summary>
        /// Returns the exponent at the desired index.
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public FieldZqElement ExponentAtIndex(int index)
        {
            if ((index < 0) || (index >= this.RepresentationLength))
            {
                throw new IndexOutOfRangeException("index out of range.");
            }

            return this.Exponents[index];
        }

        /// <summary>
        /// Compares the exponents of two witnesses.
        /// </summary>
        /// <param name="witness"></param>
        /// <returns></returns>
        public bool AreExponentsEqual(IWitness witness)
        {
            if (this.RepresentationLength != witness.RepresentationLength)
            {
                return false;
            }

            for (int i = 0; i < this.RepresentationLength; ++i)
            {
                if (this.ExponentAtIndex(i) != witness.ExponentAtIndex(i))
                {
                    return false;
                }
            }

            return true;
        }

        /// <summary>
        /// Returns true if this object represents the same DL representation as g.
        /// Checks that bases and exponents are identical, and in the same order.
        /// Also compares values, though these should be identical if bases and exponents are the same.
        /// </summary>
        /// <param name="g">object to compare</param>
        /// <returns></returns>
        public override bool Equals(Object obj)
        {

            // one obj should be a subclass of another
            if ((!obj.GetType().IsAssignableFrom(this.GetType())) && (! this.GetType().IsAssignableFrom(obj.GetType())))
            {
                return false;
            }


            IStatement statement = obj as IStatement;

            if (this.IsWitness != statement.IsWitness)
            {
                return false;
            }

            if (!AreBasesEqual(statement))
            {
                return false;
            }

            if (this.Value != statement.Value)
            {
                return false;
            }

            return true;
        }

        #region Serialization
        /// <summary>
        /// Stores Bases.
        /// </summary>
        [DataMember(Name = "Bases")]
        internal string [] _bases;

        /// <summary>
        /// Stores Exponents.  May be null.
        /// </summary>
        [DataMember(Name = "Exponents")]
        internal string [] _exponents;

        /// <summary>
        /// Stores Value.
        /// </summary>
        [DataMember(Name="Value")]
        internal string _value;


        /// <summary>
        /// Stores Value.
        /// </summary>
        [DataMember(Name = "RepLen")]
        internal int _representationLength;

        /// <summary>
        /// Serializes this class, then calls OnSerializingSubclass so subclass
        /// can complete serialization.
        /// </summary>
        /// <param name="context"></param>
        [OnSerializing]
        public void OnSerializing(StreamingContext context)
        {

            this._representationLength = this.RepresentationLength;
            this._value = CryptoSerializer.Serialize(this.Value);

            if (this.AreBasesSerializable)
            {
                this._bases = CryptoSerializer.SerializeGroupElementArray(this.Bases, "Bases");
            }
            else
            {
                this._bases = null;
            }

            if (this.IsWitness)
            {
                this._exponents = CryptoSerializer.SerializeFieldZqElementArray(this.Exponents, "exponents");
            }
            else
            {
                this._exponents = null;
            }
        }

        /// <summary>
        /// Deserializes Value, Bases, and Exponents.  If a subclass wants to override this method, the override MUST first call FinishDeserializing
        /// on the base class.
        /// </summary>
        public override void FinishDeserializing()
        {
            this.FinishDeserializing(null, null);
        }

        /// <summary>
        /// Finishes deserializing once json deserialization is complete.
        /// </summary>
        /// <param name="group">May be null. Used only if group was not serialized.</param>
        /// <param name="bases">May be null.  Used only if group was not serialized.</param>
        public void FinishDeserializing(Group group, GroupElement[] bases)
        {
            // get group
            if (this.Group == null)
            {
                if (group == null)
                {
                    throw new SerializationException("Cannot deserialize because serialized group and group argument are both null.");
                }
                this.Group = group;
            }

            // get value
            this.Value = CryptoSerializer.DeserializeGroupElement(_value, this.Group);

            // get bases
            if (this._bases == null)
            {
                if (bases == null)
                {
                    throw new SerializationException("Cannot deserialize because serialized bases and bases argument are both null.");

                }
                if (bases.Length == this._representationLength)
                {
                    this.Bases = bases;
                }
                else
                {
                    this.Bases = new GroupElement[this._representationLength];
                    for (int i = 0; i < this.Bases.Length; ++i)
                    {
                        this.Bases[i] = bases[i];
                    }
                }
            }
            else
            {
                this.Bases = CryptoSerializer.DeserializeGroupElementArray(this._bases, "bases", this.Group);
            }

            // get exponents
            if (this._exponents == null)
            {
                this.Exponents = null;
            }
            else
            {
                this.Exponents = CryptoSerializer.DeserializeFieldZqElementArray(this._exponents, "Exponents", this.Group);
                if (this.Exponents.Length != this.Bases.Length)
                {
                    throw new SerializationException("Cannot Deserialize. Must have equal number of exponents and bases.");
                }
            }


        }


        #endregion
    }
}
