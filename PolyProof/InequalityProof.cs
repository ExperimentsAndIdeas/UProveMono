//*********************************************************
//
//    Copyright (c) Microsoft. All rights reserved.
//
//    THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
//    ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
//    IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
//    PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.
//
//*********************************************************

using System;
using System.Collections;
using UProveCrypto;
using UProveCrypto.Math;
using UProveCrypto.PolyProof;
using System.Runtime.Serialization;

namespace UProveCrypto.PolyProof
{
    /// <summary>
    /// This class implements an inequality proof showing that the committed
    /// value in Pedersen Commitment X is not equal to a known value.
    /// This class also supports proving that the committed
    /// value in Pedersen Commitment X is not equal to the committed value in
    /// Pedersen Commitment Y.  It does so by proving that the committed value in Pedersen Commitment
    /// X/Y is not equal to 0.
    /// </summary>
    [DataContract]
    public class InequalityProof : GroupParameterizedSerializer
    {
        /// <summary>
        /// UProve integration proof
        /// </summary>
        [DataMember(Name = "UPIProof", EmitDefaultValue = false, Order = 1)]
        public UProveIntegrationProof UPIProof;

         /// <summary>
        /// A = G^a H^r
        /// where a and r are random FieldZqElements generated by the proof.
        /// </summary>
        public GroupElement A;
        
        /// <summary>
        /// B = G^(x-value)a
        /// where x is the oppening of Pedersen Commitment X supplied by the prover,
        /// value is known to the verifier and not equal to x, and a is a random value generated by the proof.
        /// </summary>
        public GroupElement B;

        /// <summary>
        /// Equality proof showing A and B are constructed correctly.
        /// </summary>
        [DataMember(Name = "Proof", EmitDefaultValue = false, Order = 1)]
        public EqualityProof Proof;

        /// <summary>
        /// Creates an inequality proof using prover parameters.
        /// Throws an ArgumentException if prover parameters are invalid. 
        /// </summary>
        /// <param name="prover">Prover parameters</param>
        public InequalityProof(ProverInequalityProofParameters prover)
        {
            ConstructorHelper(prover);
        }

        /// <summary>
        /// Creates an inequality proof using prover parameters.
        /// Throws an ArgumentException if prover parameters are invalid. 
        /// </summary>
        /// <param name="prover">Prover parameters</param>
        private void ConstructorHelper(ProverInequalityProofParameters prover)
        {
            if (!prover.Verify())
            {
                throw new ArgumentException("Invalid prover inequality proof parameters.");
            }
            this.Group = prover.Group;
            this.IsGroupSerializable = true;
            if (prover.CompareToKnownValue == true)
            {
                CreateProofForKnownValue(prover);
            }
            else
            {
                CreateProofForUnknownValue(prover);
            }

            this.Proof.IsGroupSerializable = false;
        }

        /// <summary>
        /// Generates proof for when prover.CompareToKnownValue=false.
        /// Computes X/Y and generates proof for showing the committed value
        /// in X/Y is not equal to 0.
        /// </summary>
        /// <param name="prover">Prover parameters for comparing CommitmentX to CommitmentY</param>
        private void CreateProofForUnknownValue(ProverInequalityProofParameters prover)
        {
            // Compute Pedersen Commitment X/Y
            PedersenCommitment newOpenX = new PedersenCommitment(
                new GroupElement[2] { prover.G, prover.H },
                new FieldZqElement[2] { prover.CommitmentX.CommittedValue - prover.CommitmentY.CommittedValue, prover.CommitmentX.Opening - prover.CommitmentY.Opening },
                prover.Group);

            // new prover parameters
            ProverInequalityProofParameters newProver = new ProverInequalityProofParameters(newOpenX, prover.FieldZq.Zero, prover);

            // generate proof
            this.CreateProofForKnownValue(newProver);
        }

        /// <summary>
        /// Genererates proof for when prover.CompareToKnownValue=true.
        /// </summary>
        /// <param name="prover"></param>
        private void CreateProofForKnownValue(ProverInequalityProofParameters prover)
        {
            // Pedersen Commitment to a random value a
            // A = g^a h^r 
            FieldZqElement a = prover.FieldZq.GetRandomElement(true);
            FieldZqElement r = prover.FieldZq.GetRandomElement(true);
            PedersenCommitment openA = new PedersenCommitment(prover.G, prover.H, a, r, prover.Group);

            // B = g^(x-value)a
            DLRepOfGroupElement openB = new DLRepOfGroupElement(
                new GroupElement[1] { prover.G },
                new FieldZqElement[1] { (prover.CommitmentX.CommittedValue - prover.Value) * a },
                prover.Group
                );

            // C = (Xg^{-value})^a h^{-ya} = B
            PedersenCommitment openC = new PedersenCommitment(
                prover.CommitmentX.Value * prover.G.Exponentiate(prover.Value.Negate()),
                prover.H,
                a,
                a.Negate() * prover.CommitmentX.Opening,
                prover.Group
                );

            // Create DL equations
            DLRepOfGroupElement[] equations = new DLRepOfGroupElement[]
             {
                 prover.CommitmentX,
                 openA,
                 openB,
                 openC
             };

            // generate proof
            EqualityMap map = this.GetEqualityMap();
            ProverEqualityParameters eqProver = new ProverEqualityParameters(equations, map, prover);
            this.Proof = new EqualityProof(eqProver);
            this.A = openA.Value;
            this.B = openB.Value;
        }

        /// <summary>
        /// Creates an EqualityMap used for Proof.  This is actually a constant that can
        /// be independently generated by the prover and verifier.
        /// </summary>
        /// <returns></returns>
        private EqualityMap GetEqualityMap()
        {
            // create equality map
            // A = g^{\delta} h^ {gamma}
            // C = (X*g^{-v})^{\delta} h^{kappa}
            EqualityMap map = new EqualityMap();
            map.Add(new PrettyName("delta", 0), new DoubleIndex(1, 0));
            map.Add(new PrettyName("delta", 0), new DoubleIndex(3, 0));
            return map;
        }

        /// <summary>
        /// Returns true if this is a valid proof given the verifier parameters.
        /// </summary>
        /// <param name="verifier"></param>
        /// <returns></returns>
        public bool Verify(VerifierInequalityProofParameters verifier)
        {
            // Check verifier parameters.
            if (! verifier.Verify())
            {
                return false;
            }

            // Check proof.
            if (verifier.CompareToKnownValue)
            {
                return this.VerifyProofForKnownValue(verifier);
            }
            else
            {
                return this.VerifyProofForUnknownValue(verifier);
            }
        }

        /// <summary>
        /// If verifier.CompareToKnownValue=false, computes X/Y and checks that this
        /// is a valid proof that the committed value in X/Y is not equal to 0.
        /// </summary>
        /// <param name="verifier"></param>
        /// <returns></returns>
        private bool VerifyProofForUnknownValue(VerifierInequalityProofParameters verifier)
        {
            // Compute X/Y
            GroupElement newClosedX = verifier.ClosedCommitmentX * verifier.ClosedCommitmentY.Exponentiate(verifier.FieldZq.NegativeOne);

            // new verifier parameters
            VerifierInequalityProofParameters newVerifier = new VerifierInequalityProofParameters(newClosedX, verifier.FieldZq.Zero, verifier);

            // Verify proof that the committed value in X/Y is not equal to 0.
            return this.Verify(newVerifier);
        }

        /// <summary>
        /// Verifies this proof for when verifier.CompareToKnownValue=true.
        /// </summary>
        /// <param name="verifier">Verifier parameters</param>
        /// <returns></returns>
        private bool VerifyProofForKnownValue(VerifierInequalityProofParameters verifier)
        {
            // B must not be 1.
            if (this.B == verifier.Group.Identity)
            {
                return false;
            }
            
            // Reconstruct DL equations from proof and verifier parameters
            ClosedPedersenCommitment closedX = new ClosedPedersenCommitment(
                new GroupElement[2] { verifier.G, verifier.H },
                verifier.ClosedCommitmentX,
                verifier.Group);

            ClosedPedersenCommitment closedA = new ClosedPedersenCommitment(
                new GroupElement[2] { verifier.G, verifier.H },
                this.A,
                verifier.Group);

            ClosedDLRepOfGroupElement closedB = new ClosedDLRepOfGroupElement(
                new GroupElement[1] { verifier.G },
                this.B,
                verifier.Group);

            ClosedPedersenCommitment closedC = new ClosedPedersenCommitment(
                 new GroupElement[2] { closedX.Value * verifier.G.Exponentiate(verifier.Value.Negate()), verifier.H },
                 this.B,
                verifier.Group);

            ClosedDLRepOfGroupElement[] equations = new ClosedDLRepOfGroupElement[]
            {
                closedX,
                closedA,
                closedB,
                closedC
            };

            // verify the proof
            EqualityMap map = this.GetEqualityMap();
            VerifierEqualityParameters eqVerifier = new VerifierEqualityParameters(equations, map, verifier);
            if (!this.Proof.Verify(eqVerifier))
            {
                return false;
            }

            return true;
        }

        #region Serialization
        /// <summary>
        /// Array containing serialization of A and B.
        /// </summary>
        [DataMember(Name = "AB", EmitDefaultValue = false, Order = 2)]
        internal string[] _AB;

        /// <summary>
        /// Serialize A and B.
        /// </summary>
        /// <param name="context"></param>
        [OnSerializing]
        internal void OnSerializing(StreamingContext context)
        {
             _AB = CryptoSerializer.SerializeGroupElementArray(new GroupElement[2] { this.A, this.B }, "AB");
        }
 
        /// <summary>
        /// Deserialize A and B. Finish deserialing Proof.
        /// </summary>
        public override void FinishDeserializing()
        { 
            GroupElement[] AB = CryptoSerializer.DeserializeGroupElementArray(this._AB, 0, 2, "AB", this.Group);
            this.A = AB[0];
            this.B = AB[1];

            if (this.Proof != null)
            {
                this.Proof.FinishDeserializing(this.Group);
            }
            if (this.UPIProof != null)
            {
                this.UPIProof.FinishDeserializing(this.Group);
            }
        }

        #endregion

        #region UProveWrapper

        /// <summary>
        /// Constructor. Creates an inequality proof that an attribute in one token is not equal to an attribute in another token.
        /// </summary>
        /// <param name="prover1">Token.</param>
        /// <param name="attributeIndexForProver1">Target attribute in first token, uses 1-based index.</param>
        /// <param name="prover2">Token</param>
        /// <param name="attributeIndexForProver2">Target attribute in second token, uses 1-based index</param>
        /// <returns>Proof of inequality.</returns>
        public InequalityProof(
            ProverPresentationProtocolParameters prover1,
            int attributeIndexForProver1,
            ProverPresentationProtocolParameters prover2,
            int attributeIndexForProver2)
        {
            // generate Pedersen Commitments to attributes
            ProverPresentationProtocolParameters[] provers = new ProverPresentationProtocolParameters[]{prover1, prover2};
            int [] attributeIndices = new int[]{attributeIndexForProver1, attributeIndexForProver2};
            PedersenCommitment[] attributeCommitments = PedersenCommitment.PedersenCommmitmentsToAttributes(provers, attributeIndices);

            // create inequality proof using Pedersen Commitmetns
            ProverInequalityProofParameters ieqProver = new ProverInequalityProofParameters(attributeCommitments[0], attributeCommitments[1], new CryptoParameters(prover1.IP));
            ConstructorHelper(ieqProver);
            
            // add UProve Integration proof
            this.UPIProof = new UProveIntegrationProof(provers, attributeIndices, attributeCommitments);
            this.UPIProof.IsGroupSerializable = false;
        }

        /// <summary>
        /// Verifies an inequality proof that two tokens have unequal attributes.
        /// </summary>
        /// <param name="verifier1">Verifier information about first token.</param>
        /// <param name="attributeIndexForVerifier1">Target attribute in first token, 1-based index.</param>
        /// <param name="verifier2">Verifier information about second token.</param>
        /// <param name="attributeIndexForVerifier2">Target attribute in second token, 1-based index.</param>
        /// <returns></returns>
        public bool Verify(
            VerifierPresentationProtocolParameters verifier1,
            int attributeIndexForVerifier1,
            VerifierPresentationProtocolParameters verifier2,
            int attributeIndexForVerifier2)
        {
            // Verify UProve Integration Proof
            if (this.UPIProof == null)
            {
                return false;
            }
            VerifierPresentationProtocolParameters[] verifiers = new VerifierPresentationProtocolParameters[2] { verifier1, verifier2 };
            int[] attributeIndices = new int[2] { attributeIndexForVerifier1, attributeIndexForVerifier2 };
            if (!this.UPIProof.Verify(verifiers, attributeIndices))
            {
                return false;
            }

            // Verify Inequality Proof
            VerifierInequalityProofParameters ieqVerifier = new VerifierInequalityProofParameters(this.UPIProof.PedersenCommitmentValues[0], this.UPIProof.PedersenCommitmentValues[1], new CryptoParameters(verifier1.IP));
            return this.Verify(ieqVerifier);
        }


        /// <summary>
        /// Constructor. Creates an inequality proof that a token attribute is not equal to some value.
        /// </summary>
        /// <param name="prover">Token description.</param>
        /// <param name="attributeIndexForProver">1-based attribute index in token.</param>
        /// <param name="attributeValue">Attribute value to compare actual token attribute.</param>
        /// <returns>Inequality proof.</returns>
        public InequalityProof(ProverPresentationProtocolParameters prover, int attributeIndexForProver, byte[] attributeValue)
        {
            // generate Pedersen Commitments to attributes
            ProverPresentationProtocolParameters[] provers = new ProverPresentationProtocolParameters[] { prover };
            int[] attributeIndices = new int[] { attributeIndexForProver };
            PedersenCommitment[] attributeCommitments = PedersenCommitment.PedersenCommmitmentsToAttributes(provers, attributeIndices);

            // create inequality proof using Pedersen Commitmetns
            FieldZqElement committedAttribute = ProtocolHelper.ComputeXi(prover.IP, attributeIndexForProver - 1, attributeValue);
            ProverInequalityProofParameters ieqProver = new ProverInequalityProofParameters(attributeCommitments[0], committedAttribute, new CryptoParameters(prover.IP));
            ConstructorHelper(ieqProver);

            // add UProve Integration proof
            this.UPIProof = new UProveIntegrationProof(provers, attributeIndices, attributeCommitments);
            this.UPIProof.IsGroupSerializable = false;
        }

        /// <summary>
        /// Verifies that a UProve token attribute is not equal to the given attribute value.
        /// </summary>
        /// <param name="verifier">Verifier info about token.</param>
        /// <param name="attributeIndexForVerifier">Target attribute, 1-based index.</param>
        /// <param name="attributeValue">Bad value for attribute.</param>
        /// <returns></returns>
        public bool Verify(
            VerifierPresentationProtocolParameters verifier,
            int attributeIndexForVerifier,
            byte [] attributeValue)
        {
            // Verify UProve Integration Proof
            if (this.UPIProof == null)
            {
                return false;
            }
            VerifierPresentationProtocolParameters[] verifiers = new VerifierPresentationProtocolParameters[1] { verifier};
            int[] attributeIndices = new int[1] { attributeIndexForVerifier};
            if (!this.UPIProof.Verify(verifiers, attributeIndices))
            {
                return false;
            }

            // Verify Inequality Proof
            FieldZqElement committedAttribute = ProtocolHelper.ComputeXi(verifier.IP, attributeIndexForVerifier - 1, attributeValue);
            VerifierInequalityProofParameters ieqVerifier = new VerifierInequalityProofParameters(this.UPIProof.PedersenCommitmentValues[0], committedAttribute, new CryptoParameters(verifier.IP));
            return this.Verify(ieqVerifier);
        }

        /// <summary>
        /// Generates a proof that two attribute values are different, without revealing them.
        /// </summary>
        /// <param name="prover1">Equality proof parameters for the first token.</param>
        /// <param name="prover2">Equality proof parameters for the second token.</param>
        /// <returns>An inequality proof.</returns>
        public static InequalityProof GenerateUProveInequalityProof(EQProofUProveProverData prover1, EQProofUProveProverData prover2)
        {
            if (!prover1.PPPP.IP.Gq.Equals(prover2.PPPP.IP.Gq))
            {
                throw new ArgumentException("both provers must share the same group");
            }
            // Create PedersenCommitments
            int commitmentIndex1 = ClosedPedersenCommitment.GetCommitmentIndex(prover1.PPPP.Committed, prover1.index);
            PedersenCommitment ped1 = new PedersenCommitment(prover1.PPPP, prover1.PP, prover1.CPV, commitmentIndex1);
            int commitmentIndex2 = ClosedPedersenCommitment.GetCommitmentIndex(prover2.PPPP.Committed, prover2.index);
            PedersenCommitment ped2 = new PedersenCommitment(prover2.PPPP, prover2.PP, prover2.CPV, commitmentIndex2);

            // Create EqualityProof
            CryptoParameters crypto = new CryptoParameters(prover1.PPPP.IP); // Can use prover2.IP
            ProverInequalityProofParameters inequalityProver = new ProverInequalityProofParameters(ped1, ped2, crypto); // compares committed values in ped1 and ped2
            return new InequalityProof(inequalityProver);
        }

        /// <summary>
        /// Generates a proof that a token attribute value is not equal to a target value.
        /// </summary>
        /// <param name="prover">Inequality proof parameters for the token.</param>
        /// <param name="target">Target value.</param>
        /// <returns>An inequality proof.</returns>
        public static InequalityProof GenerateUProveInequalityProof(EQProofUProveProverData prover, byte[] target)
        {
            return GenerateUProveInequalityProofs(prover, new byte[][] { target })[0];
        }

        /// <summary>
        /// Generates proofs that a token attribute value is not equal to any values in the target array.
        /// </summary>
        /// <param name="prover">Inequality proof parameters for the token.</param>
        /// <param name="target">Target values array.</param>
        /// <returns>An inequality proof.</returns>
        public static InequalityProof[] GenerateUProveInequalityProofs(EQProofUProveProverData prover, byte[][] target)
        {
            // Create PedersenCommitments
            int commitmentIndex = ClosedPedersenCommitment.GetCommitmentIndex(prover.PPPP.Committed, prover.index);
            PedersenCommitment ped = new PedersenCommitment(prover.PPPP, prover.PP, prover.CPV, commitmentIndex);

            // Create EqualityProof
            CryptoParameters crypto = new CryptoParameters(prover.PPPP.IP);
            InequalityProof[] proofs = new InequalityProof[target.Length];
            for (int i = 0; i < target.Length; i++)
            {
                FieldZqElement targetValue = ProtocolHelper.ComputeXi(prover.PPPP.IP, prover.index - 1, target[i]);
                proofs[i] = new InequalityProof(new ProverInequalityProofParameters(ped, targetValue, crypto));
            }
            return proofs;
        }

        /// <summary>
        /// Verifies a proof that two tokens share an attribute value, without revealing it.
        /// </summary>
        /// <param name="verifier1">Equality proof parameters for the first token.</param>
        /// <param name="verifier2">Equality proof parameters for the second token.</param>
        /// <param name="eQProof">The equality proof to verify.</param>
        /// <exception cref="InvalidUProveArtifactException">Thrown if the proof is invalid.</exception>
        public static void VerifyUProveEqualityProof(EQProofUProveVerifierData verifier1, EQProofUProveVerifierData verifier2, InequalityProof iNeqProof)
        {
            int commitmentIndex1 = ClosedPedersenCommitment.GetCommitmentIndex(verifier1.VPPP.Committed, verifier1.index);
            int commitmentIndex2 = ClosedPedersenCommitment.GetCommitmentIndex(verifier2.VPPP.Committed, verifier2.index);
            ClosedPedersenCommitment closedPed1 = new ClosedPedersenCommitment(verifier1.VPPP.IP, verifier1.PP, commitmentIndex1);
            ClosedPedersenCommitment closedPed2 = new ClosedPedersenCommitment(verifier2.VPPP.IP, verifier2.PP, commitmentIndex2);
            CryptoParameters crypto = new CryptoParameters(verifier1.VPPP.IP); // Can use prover2.IP
            
            VerifierInequalityProofParameters inequalityVerifier = new VerifierInequalityProofParameters(closedPed1.Value, closedPed2.Value, crypto);
            if (!iNeqProof.Verify(inequalityVerifier))
            {
                throw new InvalidUProveArtifactException("invalid equality proof");
            }
        }

        /// <summary>
        /// Verifies a proof that a token attribute value is not equal to a target value.
        /// </summary>
        /// <param name="verifier">Equality proof parameters for the token.</param>
        /// <param name="target">Target value.</param>
        /// <param name="eQProof">The inequality proof to verify.</param>
        /// <exception cref="InvalidUProveArtifactException">Thrown if the proof is invalid.</exception>
        public static void VerifyUProveEqualityProof(EQProofUProveVerifierData verifier, byte[] target, InequalityProof iNeqProof)
        {
            VerifyUProveEqualityProofs(verifier, new byte[][] { target }, new InequalityProof[] { iNeqProof });
        }

        /// <summary>
        /// Verifies proofs that a token attribute value is not equal to a any of the target values.
        /// </summary>
        /// <param name="verifier">Equality proof parameters for the token.</param>
        /// <param name="target">Target values.</param>
        /// <param name="eQProof">The inequality proofs to verify.</param>
        /// <exception cref="InvalidUProveArtifactException">Thrown if a proof is invalid.</exception>
        public static void VerifyUProveEqualityProofs(EQProofUProveVerifierData verifier, byte[][] target, InequalityProof[] iNeqProof)
        {
            if (target == null || iNeqProof == null || target.Length != iNeqProof.Length)
            {
                throw new ArgumentException("target and iNeqProof must have the same length");
            }

            int commitmentIndex = ClosedPedersenCommitment.GetCommitmentIndex(verifier.VPPP.Committed, verifier.index);
            ClosedPedersenCommitment closedPed = new ClosedPedersenCommitment(verifier.VPPP.IP, verifier.PP, commitmentIndex);
            CryptoParameters crypto = new CryptoParameters(verifier.VPPP.IP);

            for (int i = 0; i < target.Length; i++)
            {
                FieldZqElement targetValue = ProtocolHelper.ComputeXi(verifier.VPPP.IP, verifier.index - 1, target[i]);
                if (!iNeqProof[i].Verify(new VerifierInequalityProofParameters(closedPed.Value, targetValue, crypto)))
                {
                    throw new InvalidUProveArtifactException("invalid equality proof");
                }
            }
        }

        #endregion
    }
}
